
// This file was generated by [tauri-specta](https://github.com/oscartbeaumont/tauri-specta). Do not edit this file manually.

/** user-defined commands **/


export const commands = {
async getCharacters() : Promise<Result<CharacterView[], CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_characters") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getCharacter(id: number) : Promise<Result<CharacterView | null, CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_character", { id }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async createCharacter(name: string) : Promise<Result<CharacterView, CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("create_character", { name }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Delete a character permanently.
 */
async deleteCharacter(id: number) : Promise<Result<null, CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("delete_character", { id }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getDraftCharacter() : Promise<Result<CharacterView | null, CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_draft_character") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async saveCharacter() : Promise<Result<CharacterView, CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("save_character") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async discardDraft() : Promise<Result<null, CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("discard_draft") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async loadCharacterIntoDraft(id: number) : Promise<Result<CharacterView, CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("load_character_into_draft", { id }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async updateDraftBasicInfo(name: string, isWildCard: boolean, background: string | null, description: string | null) : Promise<Result<CharacterView, CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("update_draft_basic_info", { name, isWildCard, background, description }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async updateCharacterStatus(id: number, wounds: number, fatigue: number, powerPointsUsed: number) : Promise<Result<CharacterView, CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("update_character_status", { id, wounds, fatigue, powerPointsUsed }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Update a character's portrait.
 * Accepts base64-encoded image data and mime type (e.g., "image/png" or "image/jpeg").
 */
async updateCharacterPortrait(id: number, imageBase64: string, mimeType: string) : Promise<Result<CharacterView, CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("update_character_portrait", { id, imageBase64, mimeType }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Clear a character's portrait.
 */
async clearCharacterPortrait(id: number) : Promise<Result<CharacterView, CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("clear_character_portrait", { id }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getAncestries() : Promise<Result<AncestryView[], CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_ancestries") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async updateDraftAncestry(ancestryId: number | null) : Promise<Result<CharacterView, CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("update_draft_ancestry", { ancestryId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async updateDraftAncestryChoice(choiceId: number, selectedOptionId: number | null) : Promise<Result<CharacterView, CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("update_draft_ancestry_choice", { choiceId, selectedOptionId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getHindrances() : Promise<Result<HindranceView[], CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_hindrances") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async addDraftHindrance(hindranceId: number) : Promise<Result<CharacterView, CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("add_draft_hindrance", { hindranceId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async removeDraftHindrance(hindranceId: number) : Promise<Result<CharacterView, CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("remove_draft_hindrance", { hindranceId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getEdges() : Promise<Result<EdgeWithAvailability[], CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_edges") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async addDraftEdge(edgeId: number, notes: string | null) : Promise<Result<CharacterView, CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("add_draft_edge", { edgeId, notes }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async removeDraftEdge(edgeId: number) : Promise<Result<CharacterView, CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("remove_draft_edge", { edgeId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async allocateHindrancePointsToEdges(points: number) : Promise<Result<CharacterView, CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("allocate_hindrance_points_to_edges", { points }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getArcaneBackgrounds() : Promise<Result<ArcaneBackgroundWithAvailability[], CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_arcane_backgrounds") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async addDraftArcaneBackground(arcaneBackgroundId: number) : Promise<Result<CharacterView, CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("add_draft_arcane_background", { arcaneBackgroundId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async removeDraftArcaneBackground(arcaneBackgroundId: number) : Promise<Result<CharacterView, CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("remove_draft_arcane_background", { arcaneBackgroundId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Update a character's arcane background choice selection.
 * 
 * For choosable_starting_power choices, this toggles the power selection.
 * Built-in hindrances and required starting powers cannot be changed.
 */
async updateDraftArcaneBackgroundChoice(choiceId: number, selectedOptionId: number, isSelecting: boolean) : Promise<Result<CharacterView, CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("update_draft_arcane_background_choice", { choiceId, selectedOptionId, isSelecting }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getPowers() : Promise<Result<PowerWithAvailability[], CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_powers") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async addDraftPower(powerId: number) : Promise<Result<CharacterView, CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("add_draft_power", { powerId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async removeDraftPower(powerId: number) : Promise<Result<CharacterView, CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("remove_draft_power", { powerId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getSkills() : Promise<Result<SkillView[], CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_skills") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getGameConfig() : Promise<GameConfig> {
    return await TAURI_INVOKE("get_game_config");
},
async updateDraftSkill(skillId: number, increment: boolean) : Promise<Result<CharacterView, CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("update_draft_skill", { skillId, increment }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async allocateHindrancePointsToSkills(points: number) : Promise<Result<CharacterView, CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("allocate_hindrance_points_to_skills", { points }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Check which edges would be invalidated if a skill is decremented.
 * Returns the list of edge names that would lose their requirements.
 */
async checkSkillDecrementImpact(skillId: number) : Promise<Result<string[], CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("check_skill_decrement_impact", { skillId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async updateDraftAttribute(attributeId: number, increment: boolean) : Promise<Result<CharacterView, CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("update_draft_attribute", { attributeId, increment }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async allocateHindrancePointsToAttributes(points: number) : Promise<Result<CharacterView, CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("allocate_hindrance_points_to_attributes", { points }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Check which edges would be invalidated if an attribute is decremented.
 * Returns the list of edge names that would lose their requirements.
 */
async checkAttributeDecrementImpact(attributeId: number) : Promise<Result<string[], CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("check_attribute_decrement_impact", { attributeId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getCharacterNotes(characterId: number) : Promise<Result<CharacterNoteValue[], CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_character_notes", { characterId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async createCharacterNote(characterId: number, title: string, body: string) : Promise<Result<CharacterNoteValue, CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("create_character_note", { characterId, title, body }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async updateCharacterNote(noteId: number, title: string, body: string) : Promise<Result<CharacterNoteValue, CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("update_character_note", { noteId, title, body }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async deleteCharacterNote(noteId: number) : Promise<Result<null, CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("delete_character_note", { noteId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get all available gear items.
 */
async getAllGear() : Promise<Result<GearView[], CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_all_gear") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get all gear categories.
 */
async getGearCategories() : Promise<Result<GearCategoryView[], CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_gear_categories") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get gear items by category.
 */
async getGearByCategory(categoryId: number) : Promise<Result<GearView[], CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_gear_by_category", { categoryId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get a character's gear inventory.
 */
async getCharacterGear(characterId: number) : Promise<Result<CharacterGearValue[], CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_character_gear", { characterId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Add gear to a character without paying (GM grants, found items, starting gear).
 * If the gear is a pack, adds individual pack contents instead of the pack itself.
 */
async addGear(characterId: number, gearId: number, quantity: number) : Promise<Result<CharacterView, CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("add_gear", { characterId, gearId, quantity }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Purchase gear for a character (deducts from wealth).
 * If the gear is a pack, adds individual pack contents instead of the pack itself.
 */
async purchaseGear(characterId: number, gearId: number, quantity: number) : Promise<Result<CharacterView, CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("purchase_gear", { characterId, gearId, quantity }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Sell gear from a character (at 50% value).
 */
async sellGear(characterGearId: number, quantity: number) : Promise<Result<CharacterView, CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("sell_gear", { characterGearId, quantity }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Remove gear from a character without selling (lost, destroyed, given away).
 */
async removeGear(characterGearId: number, quantity: number) : Promise<Result<CharacterView, CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("remove_gear", { characterGearId, quantity }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Toggle whether gear is equipped.
 */
async toggleGearEquipped(characterGearId: number) : Promise<Result<CharacterView, CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("toggle_gear_equipped", { characterGearId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Update custom notes on a gear item.
 */
async updateGearNotes(characterGearId: number, notes: string | null) : Promise<Result<CharacterView, CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("update_gear_notes", { characterGearId, notes }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Update a character's wealth directly.
 */
async updateCharacterWealth(characterId: number, wealth: number) : Promise<Result<CharacterView, CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("update_character_wealth", { characterId, wealth }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get the available advancement options for a character.
 */
async getAdvancementOptions(characterId: number) : Promise<Result<AdvancementOptions, CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_advancement_options", { characterId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Take an edge as an advancement.
 */
async takeEdgeAdvance(characterId: number, edgeId: number, notes: string | null) : Promise<Result<CharacterAdvanceValue, CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("take_edge_advance", { characterId, edgeId, notes }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Take an attribute increase as an advancement.
 */
async takeAttributeAdvance(characterId: number, attributeId: number) : Promise<Result<CharacterAdvanceValue, CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("take_attribute_advance", { characterId, attributeId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Take an expensive skill increase (one skill at or above linked attribute) as an advancement.
 */
async takeExpensiveSkillAdvance(characterId: number, skillId: number) : Promise<Result<CharacterAdvanceValue, CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("take_expensive_skill_advance", { characterId, skillId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Take two cheap skill increases (skills below linked attribute) as an advancement.
 */
async takeCheapSkillAdvance(characterId: number, skillId1: number, skillId2: number) : Promise<Result<CharacterAdvanceValue, CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("take_cheap_skill_advance", { characterId, skillId1, skillId2 }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Take a hindrance modification as an advancement.
 * Actions: "remove_minor", "reduce_major", "remove_major_half"
 */
async takeHindranceAdvance(characterId: number, hindranceId: number, action: string) : Promise<Result<CharacterAdvanceValue, CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("take_hindrance_advance", { characterId, hindranceId, action }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Undo the most recent advancement for a character.
 * Returns true if an advance was successfully undone.
 */
async undoLastAdvance(characterId: number) : Promise<Result<boolean, CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("undo_last_advance", { characterId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Get the advancement history for a character.
 */
async getAdvancementHistory(characterId: number) : Promise<Result<CharacterAdvanceValue[], CommandError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_advancement_history", { characterId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
}
}

/** user-defined events **/



/** user-defined constants **/



/** user-defined types **/

/**
 * The type of advancement taken.
 */
export type AdvanceType = "edge" | "attribute" | "skill_expensive" | "skill_cheap" | "hindrance"
/**
 * Options available for a character's next advancement.
 */
export type AdvancementOptions = { 
/**
 * Can take an edge (always true if requirements are met)
 */
can_take_edge: boolean; 
/**
 * Can increase an attribute (limited by rank rules)
 */
can_increase_attribute: boolean; 
/**
 * Reason why attribute increase is not available (if applicable)
 */
attribute_blocked_reason: string | null; 
/**
 * Attributes available for advancement
 */
attribute_options: AttributeAdvanceOption[]; 
/**
 * Can increase one expensive skill (at/above linked attribute)
 */
can_increase_expensive_skill: boolean; 
/**
 * Skills at or above linked attribute (one per advance)
 */
expensive_skill_options: SkillAdvanceOption[]; 
/**
 * Can increase two cheap skills (below linked attribute)
 */
can_increase_cheap_skills: boolean; 
/**
 * Skills below linked attribute (pick two per advance)
 */
cheap_skill_options: SkillAdvanceOption[]; 
/**
 * Can remove/reduce a hindrance
 */
can_modify_hindrance: boolean; 
/**
 * Hindrances available for modification with their actions
 */
hindrance_options: HindranceAdvanceOption[]; 
/**
 * Current advance number (what number this advance would be)
 */
next_advance_number: number; 
/**
 * Current rank name
 */
current_rank: string; 
/**
 * Rank after taking this advance
 */
rank_after_advance: string }
/**
 * View model for ammunition statistics
 */
export type AmmunitionStatsView = { ammo_type: string; quantity_per_unit: number; notes: string | null }
/**
 * View model for an ancestry choice option.
 */
export type AncestryChoiceOptionView = { id: number; option_type: AncestryOptionType; option_id: number | null; description: string | null }
/**
 * Types of ancestry choices.
 */
export type AncestryChoiceType = "free_edge" | "mandatory_hindrance" | "ancestral_enemy"
/**
 * View model for an ancestry choice with its options.
 */
export type AncestryChoiceView = { id: number; choice_type: AncestryChoiceType; choice_category: string | null; min_selections: number; max_selections: number; description: string; options: AncestryChoiceOptionView[] }
/**
 * Types of ancestry choice options.
 */
export type AncestryOptionType = "edge" | "hindrance" | "ancestry"
/**
 * View model for an ancestry with all its related data.
 */
export type AncestryView = { id: number; name: string; source: string; description: string; choices: AncestryChoiceView[]; modifiers: Modifier[]; requirements: RequirementTree }
/**
 * View model for an arcane background choice option.
 */
export type ArcaneBackgroundChoiceOptionView = { id: number; option_type: ArcaneBackgroundOptionType; option_id: number | null; description: string | null; position: number }
/**
 * Types of arcane background choices.
 */
export type ArcaneBackgroundChoiceType = "available_power" | "required_starting_power" | "choosable_starting_power" | "built_in_hindrance" | "special_ability" | "edge_category"
/**
 * View model for an arcane background choice with its options.
 */
export type ArcaneBackgroundChoiceView = { id: number; choice_type: ArcaneBackgroundChoiceType; choice_category: string | null; min_selections: number; max_selections: number; description: string; position: number; options: ArcaneBackgroundChoiceOptionView[] }
/**
 * Types of arcane background choice options.
 */
export type ArcaneBackgroundOptionType = "power" | "hindrance" | "ability" | "edge_category"
/**
 * View model for an arcane background with its requirements and choices.
 */
export type ArcaneBackgroundView = { id: number; name: string; arcane_skill_id: number; arcane_skill_name: string | null; starting_powers: number; starting_power_points: number; has_power_list: boolean; source: string; description: string; requirements: RequirementTree; choices: ArcaneBackgroundChoiceView[] }
/**
 * Arcane background with its availability status for the current character.
 */
export type ArcaneBackgroundWithAvailability = { arcane_background: ArcaneBackgroundView; is_available: boolean; requirement_statuses: RequirementStatus[] }
/**
 * View model for armor statistics
 */
export type ArmorStatsView = { armor_value: number; coverage: string; min_strength: number | null; is_heavy: boolean }
/**
 * An attribute that can be increased via advancement.
 */
export type AttributeAdvanceOption = { id: number; name: string; 
/**
 * Base die size (without modifiers)
 */
current_die: number; 
/**
 * Effective die size (with modifiers applied) - for display
 */
effective_die: number; 
/**
 * Base die size after advancement
 */
next_die: number; 
/**
 * Effective die size after advancement (with modifiers) - for display
 */
effective_next_die: number; is_maxed: boolean }
export type AttributeView = { id: number; name: string; description: string; base_die: Die }
/**
 * Represents an advance that a character has taken, with resolved names for display.
 */
export type CharacterAdvanceValue = { id: number; advance_number: number; advance_type: AdvanceType; description: string; created_at: string }
/**
 * Represents a character's selection for an ancestry choice.
 */
export type CharacterAncestryChoiceValue = { choice: AncestryChoiceView; selected_option: AncestryChoiceOptionView | null }
/**
 * Represents a character's selection for an arcane background choice.
 */
export type CharacterArcaneBackgroundChoiceValue = { choice: ArcaneBackgroundChoiceView; selected_options: ArcaneBackgroundChoiceOptionView[] }
/**
 * Represents an arcane background that a character has, along with when it was acquired.
 */
export type CharacterArcaneBackgroundValue = { arcane_background: ArcaneBackgroundView; advance_taken: number | null }
export type CharacterAttributeValue = { attribute: AttributeView; 
/**
 * The purchased die value (what the player spent points on).
 */
die: Die; 
/**
 * The effective die value (purchased + modifiers from ancestry/edges/etc).
 */
effective_die: Die; 
/**
 * The effective base die (d4 + modifiers) - the starting point with modifiers.
 */
base_die: Die; 
/**
 * The effective max die (d12 + modifiers) - the ceiling with modifiers.
 */
max_die: Die; 
/**
 * Whether this attribute can be incremented (has points, not at max).
 */
can_increment: boolean; 
/**
 * Whether this attribute can be decremented (not at base).
 */
can_decrement: boolean }
/**
 * Represents an edge that a character has taken, along with metadata about when/how it was acquired.
 */
export type CharacterEdgeValue = { edge: EdgeView; advance_taken: number; notes: string | null; source: string }
/**
 * Represents a gear item owned by a character
 */
export type CharacterGearValue = { id: number; gear: GearView; quantity: number; is_equipped: boolean; custom_notes: string | null; 
/**
 * Total weight of this gear stack (weight * quantity)
 */
total_weight: number }
/**
 * Represents a hindrance that a character has taken, along with metadata about how it was acquired.
 */
export type CharacterHindranceValue = { hindrance: HindranceView; source: string }
/**
 * Represents a note attached to a character.
 */
export type CharacterNoteValue = { id: number; title: string; body: string; created_at: string; updated_at: string }
/**
 * Represents a power that a character has learned, along with when it was acquired.
 */
export type CharacterPowerValue = { power: PowerView; advance_taken: number | null; 
/**
 * Whether this power is locked (e.g., required starting power from arcane background).
 * Locked powers cannot be removed by the player.
 */
is_locked: boolean }
export type CharacterSkillValue = { skill: SkillView; 
/**
 * The purchased die value (None for untrained).
 */
die: Die | null; 
/**
 * The effective die value (purchased + modifiers). None for untrained (UI displays d4-2).
 */
effective_die: Die | null; 
/**
 * Whether the current die is above the linked attribute's die.
 */
is_above_attribute: boolean; 
/**
 * The cost to increment this skill (1 if at/below attribute, 2 if above).
 */
increment_cost: number; 
/**
 * Whether this skill can be incremented (has points, not at max).
 */
can_increment: boolean; 
/**
 * Whether this skill can be decremented (has die, and not a core skill at d4).
 */
can_decrement: boolean }
/**
 * Complete view of a character with all related data resolved.
 */
export type CharacterView = { id: number; is_wild_card: boolean; name: string; ancestry: AncestryView | null; ancestry_choices: CharacterAncestryChoiceValue[]; rank: Rank; current_advances: number; attributes: CharacterAttributeValue[]; skills: CharacterSkillValue[]; edges: CharacterEdgeValue[]; hindrances: CharacterHindranceValue[]; arcane_backgrounds: CharacterArcaneBackgroundValue[]; arcane_background_choices: CharacterArcaneBackgroundChoiceValue[]; powers: CharacterPowerValue[]; power_points: number; power_points_used: number; wounds: number; fatigue: number; notes: CharacterNoteValue[]; gear: CharacterGearValue[]; encumbrance: EncumbranceInfo; modifiers: Modifier[]; derived_stats: DerivedStatsView; attribute_points_spent: number; attribute_points_earned: number; skill_points_spent: number; skill_points_earned: number; hindrance_points_spent: number; hindrance_points_earned: number; hindrance_points_to_edges: number; hindrance_points_to_attributes: number; hindrance_points_to_skills: number; hindrance_points_to_wealth: number; wealth: number; background: string | null; description: string | null; portrait_data_url: string | null }
/**
 * Error type for Tauri commands, providing structured error information to the frontend.
 */
export type CommandError = 
/**
 * Database operation failed
 */
{ kind: "Database"; message: string } | 
/**
 * Requested entity was not found
 */
{ kind: "NotFound"; message: string } | 
/**
 * Validation constraint was violated
 */
{ kind: "Validation"; message: string } | 
/**
 * No draft character in progress
 */
{ kind: "NoDraft"; message: string } | 
/**
 * Internal state error (mutex, etc.)
 */
{ kind: "State"; message: string }
/**
 * Derived characteristics calculated from a character's attributes, skills, and modifiers.
 * 
 * These values are computed by CharacterView::compute_effective_values() and represent
 * the final calculated stats after all modifiers from edges, hindrances, and ancestries
 * are applied.
 */
export type DerivedStatsView = { 
/**
 * Movement rate in tabletop inches per round. Base is 6.
 */
pace: number; 
/**
 * Defense against melee attacks. Base is 2 + half Fighting die.
 */
parry: number; 
/**
 * Damage resistance. Base is 2 + half Vigor die + Size.
 */
toughness: number; 
/**
 * Size modifier. Normal humans are 0. Affects Toughness.
 */
size: number }
/**
 * A SWADE die value.
 * 
 * Represents die sizes from d4 to d12, and beyond d12 with modifiers (d12+1, d12+2, etc.).
 * The progression is: d4 → d6 → d8 → d10 → d12 → d12+1 → d12+2 → ...
 */
export type Die = { size: number; modifier: number }
/**
 * Edge category types in SWADE.
 */
export type EdgeCategory = "Background" | "Combat" | "Leadership" | "Power" | "Professional" | "Social" | "Weird"
export type EdgeView = { id: number; name: string; category: EdgeCategory; source: string; description: string; can_take_multiple_times: boolean; modifiers: Modifier[]; requirements: RequirementTree }
/**
 * Edge with its availability status for the current character.
 */
export type EdgeWithAvailability = { edge: EdgeView; is_available: boolean; requirement_statuses: RequirementStatus[] }
/**
 * Information about a character's encumbrance status
 */
export type EncumbranceInfo = { 
/**
 * Current total weight carried
 */
current_weight: number; 
/**
 * Maximum weight before encumbrance penalty
 */
load_limit: number; 
/**
 * Whether the character is encumbered
 */
is_encumbered: boolean; 
/**
 * Penalty applied if encumbered (-2 to all physical tasks)
 */
encumbrance_penalty: number }
/**
 * Static game configuration constants for SWADE.
 * Provides a single source of truth for game rules that the frontend can query.
 */
export type GameConfig = { 
/**
 * Maximum hindrance points a character can earn (4)
 */
max_hindrance_points: number; 
/**
 * Base attribute points for character creation (5)
 */
base_attribute_points: number; 
/**
 * Base skill points for character creation (12)
 */
base_skill_points: number; 
/**
 * Hindrance points required per attribute point (2)
 */
hindrance_points_per_attribute: number; 
/**
 * Hindrance points required per skill point (1)
 */
hindrance_points_per_skill: number; 
/**
 * Hindrance points required per edge (2)
 */
hindrance_points_per_edge: number; 
/**
 * Skill cost when at or below linked attribute (1)
 */
skill_cost_at_or_below_attribute: number; 
/**
 * Skill cost when above linked attribute (2)
 */
skill_cost_above_attribute: number }
/**
 * View model for a gear category
 */
export type GearCategoryView = { id: number; name: string; description: string | null }
/**
 * View model for a gear item with all related data
 */
export type GearView = { id: number; name: string; category: GearCategoryView; era: string; cost: number; weight: number; source: string; notes: string | null; description: string | null; 
/**
 * Modifiers this gear provides (Parry, Toughness, skill bonuses)
 */
modifiers: Modifier[]; 
/**
 * Requirements for this gear (minimum strength, etc.)
 * Interpreted as graduated penalties rather than hard requirements
 */
requirements: RequirementTree; 
/**
 * Type-specific stats (only one will be populated based on category)
 */
weapon_stats: WeaponStatsView | null; armor_stats: ArmorStatsView | null; shield_stats: ShieldStatsView | null; ammunition_stats: AmmunitionStatsView | null; poison_stats: PoisonStatsView | null; 
/**
 * Pack contents (only populated for items in the Packs category)
 */
pack_contents: PackContentsView[] | null }
/**
 * The action that can be taken on a hindrance.
 */
export type HindranceAction = 
/**
 * Remove a minor hindrance entirely
 */
"remove_minor" | 
/**
 * Reduce a major hindrance to its minor version
 */
"reduce_major" | 
/**
 * Bank one advance toward removing a major (first of two)
 */
"remove_major_half" | 
/**
 * Complete removal of a major hindrance (second of two)
 */
"complete_major_removal"
/**
 * A hindrance that can be modified via advancement.
 */
export type HindranceAdvanceOption = { id: number; name: string; description: string; severity: string; 
/**
 * The action available for this hindrance
 */
action: HindranceAction; 
/**
 * Human-readable label for the action
 */
action_label: string; 
/**
 * Whether this hindrance has a banked advance
 */
is_banked: boolean }
export type HindranceView = { id: number; name: string; severity: Severity; point_value: number; companion_hindrance_id: number | null; source: string; description: string; modifiers: Modifier[]; requirements: RequirementTree }
export type Modifier = { id: number; target_type: string | null; target_identifier: string | null; value_type: string; value: number | null; description: string; created_at: string; updated_at: string }
/**
 * View model for a single item within a pack
 */
export type PackContentsView = { 
/**
 * The gear item in this pack
 */
item: GearView; 
/**
 * How many of this item the pack contains
 */
quantity: number; 
/**
 * Optional notes about this item in the pack context
 */
notes: string | null }
/**
 * View model for poison statistics
 */
export type PoisonStatsView = { poison_type: string; delivery_method: string; affected_attribute: string | null; notes: string | null }
export type PowerView = { id: number; name: string; power_points: number; range: string; duration: string; source: string; description: string; modifiers: Modifier[]; requirements: RequirementTree }
/**
 * Power with its availability status for the current character.
 */
export type PowerWithAvailability = { power: PowerView; is_available: boolean; requirement_statuses: RequirementStatus[] }
export type Rank = { id: number; name: string; min_advances: number; max_advances: number | null; description: string; created_at: string; updated_at: string }
export type Requirement = { id: number; requirement_type: string; target_id: number | null; value: number | null; description: string; created_at: string; updated_at: string }
/**
 * A node in a requirement expression tree.
 * Represents boolean logic (AND, OR, NOT) or a leaf requirement.
 */
export type RequirementNode = 
/**
 * All children must be satisfied
 */
{ And: RequirementTree[] } | 
/**
 * At least one child must be satisfied
 */
{ Or: RequirementTree[] } | 
/**
 * The child must NOT be satisfied
 */
{ Not: RequirementTree } | 
/**
 * A leaf requirement to evaluate
 */
{ Leaf: Requirement }
/**
 * Status of a single requirement evaluation.
 */
export type RequirementStatus = { 
/**
 * Human-readable description of the requirement
 */
description: string; 
/**
 * Whether this requirement is met
 */
is_met: boolean }
/**
 * A tree structure representing requirements with boolean logic.
 * Built from requirement_expressions and requirements tables.
 */
export type RequirementTree = { node: RequirementNode }
/**
 * Hindrance severity level.
 */
export type Severity = "minor" | "major"
/**
 * View model for shield statistics
 */
export type ShieldStatsView = { parry_bonus: number; cover_penalty: number; min_strength: number | null; notes: string | null }
/**
 * A skill that can be increased via advancement.
 */
export type SkillAdvanceOption = { id: number; name: string; 
/**
 * Base die size (0 if untrained)
 */
current_die: number; 
/**
 * Effective die size (with modifiers applied) - for display
 */
effective_die: number; 
/**
 * Base die size after advancement
 */
next_die: number; 
/**
 * Effective die size after advancement (with modifiers) - for display
 */
effective_next_die: number; is_maxed: boolean }
export type SkillView = { id: number; name: string; description: string; linked_attribute_id: number; is_core_skill: boolean; default_die: Die | null; max_die: Die; source: string }
/**
 * View model for weapon statistics
 */
export type WeaponStatsView = { damage: string; ap: number; range_short: number | null; range_medium: number | null; range_long: number | null; rof: number | null; shots: number | null; min_strength: number | null; is_two_handed: boolean; reach: number | null; blast_template: string | null; notes: string | null }

/** tauri-specta globals **/

import {
	invoke as TAURI_INVOKE,
	Channel as TAURI_CHANNEL,
} from "@tauri-apps/api/core";
import * as TAURI_API_EVENT from "@tauri-apps/api/event";
import { type WebviewWindow as __WebviewWindow__ } from "@tauri-apps/api/webviewWindow";

type __EventObj__<T> = {
	listen: (
		cb: TAURI_API_EVENT.EventCallback<T>,
	) => ReturnType<typeof TAURI_API_EVENT.listen<T>>;
	once: (
		cb: TAURI_API_EVENT.EventCallback<T>,
	) => ReturnType<typeof TAURI_API_EVENT.once<T>>;
	emit: null extends T
		? (payload?: T) => ReturnType<typeof TAURI_API_EVENT.emit>
		: (payload: T) => ReturnType<typeof TAURI_API_EVENT.emit>;
};

export type Result<T, E> =
	| { status: "ok"; data: T }
	| { status: "error"; error: E };

function __makeEvents__<T extends Record<string, any>>(
	mappings: Record<keyof T, string>,
) {
	return new Proxy(
		{} as unknown as {
			[K in keyof T]: __EventObj__<T[K]> & {
				(handle: __WebviewWindow__): __EventObj__<T[K]>;
			};
		},
		{
			get: (_, event) => {
				const name = mappings[event as keyof T];

				return new Proxy((() => {}) as any, {
					apply: (_, __, [window]: [__WebviewWindow__]) => ({
						listen: (arg: any) => window.listen(name, arg),
						once: (arg: any) => window.once(name, arg),
						emit: (arg: any) => window.emit(name, arg),
					}),
					get: (_, command: keyof __EventObj__<any>) => {
						switch (command) {
							case "listen":
								return (arg: any) => TAURI_API_EVENT.listen(name, arg);
							case "once":
								return (arg: any) => TAURI_API_EVENT.once(name, arg);
							case "emit":
								return (arg: any) => TAURI_API_EVENT.emit(name, arg);
						}
					},
				});
			},
		},
	);
}
